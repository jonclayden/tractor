#! /usr/bin/env Rscript --vanilla --default-packages=utils

status <- 1

# spec <- matrix(c(
#     "help",         "h", 0, NA, "Display this usage information and exit",
#     "nohistory",    "z", 0, NA, "Do not write the command line used into a history log file",
#     "stems",        "n", 0, NA, "Do not append a suffix to image filenames, giving the file stems instead",
#     "relative",     "r", 0, NA, "Generate paths relative to the working directory, rather than absolute paths",
#     "workdir",      "w", 1, "character", "Specify the working directory, which will be created if necessary. Default is '.', the current directory"),
# byrow=TRUE, ncol=5L)
# 
# print(getopt::getopt(spec))
# cat(getopt::getopt(spec, usage=TRUE))

# library(argparser)
# 
# parser <- arg_parser("furrow (program v3.4.1, distribution v$distribution_version)\nChannel a command through TractoR's shorthand") |>
#             add_argument("-z", help="Do not write the command line used into a history log file", short="-z", flag=TRUE) |>
#             add_argument("-n", help="Do not append a suffix to image filenames, giving the file stems instead", short="-n", flag=TRUE) |>
#             add_argument("-r", help="Generate paths relative to the working directory, rather than absolute paths", flag=TRUE) |>
#             add_argument("--workdir", help="Specify the working directory, which will be created if necessary. Default is '.', the current directory", default=".")
# 
# print(parse_args(parser))
# print(parser)

if (Sys.getenv("TRACTOR_HOME") != "")
    .libPaths(c(file.path(Sys.getenv("TRACTOR_HOME"), "lib", "R"), .libPaths()))

library(arrg)
library(tractor.utils)

if (Sys.getenv("COLUMNS") != "")
    options(width=as.integer(Sys.getenv("COLUMNS")))

# opt <- function (label, description, arg = FALSE, default = NA_character_) {
#     label <- ore_split(ore("|",syntax="fixed"), label)
#     shortForm <- label %~% "^-?\\w$"
#     if (length(label) == 0L || sum(shortForm) > 1L || sum(!shortForm) > 1L)
#         stop("Too few or too many labels for option")
#     
#     argname <- NA_character_
#     if (is.character(arg)) {
#         argname <- arg
#         arg <- TRUE
#     }
#     arg <- arg || !is.na(default)
#     if (!arg) default <- FALSE
#     
#     data.frame(short=ifelse(any(shortForm),label[shortForm],NA),
#                long=ifelse(any(!shortForm),label[!shortForm],NA),
#                name=label[which.max(nchar(label))],
#                description=description,
#                arg=arg,
#                argname=argname,
#                default=default,
#                mode=storage.mode(default))
# }
# 
# pat <- function (..., options = NULL) {
#     return (structure(list(...), options=options))
# }
# 
# expandArgs <- function (args, validShort) {
#     result <- character(0)
#     for (i in seq_along(args)) {
#         if (args[i] %~% ore("^-((", paste(validShort,collapse="|"), ")+)(.*)$")) {
#             result <- c(result, paste0("-",unlist(strsplit(ore_lastmatch()[,1], ""))))
#             if (!is.na(ore_lastmatch()[,3]))
#                 result <- c(result, ore_lastmatch()[,3])
#         } else {
#             result <- c(result, args[i])
#         }
#     }
#     return (result)
# }
# 
# "%as%" <- function (X, Y) {
#     storage.mode(X) <- Y
#     return (X)
# }
# 
# resolvePattern <- function (spec, optInfo) {
#     argInfo <- list()
#     
#     if (length(spec) > 0) {
#         argMatches <- ore_search("^(\\w+)(\\.\\.\\.)?(\\?)?$", unlist(spec), simplify=FALSE)
#         argInfo <- lapply(argMatches, function (m) {
#             if (is.null(m))
#                 stop("Format of positional arguments is invalid")
#             else
#                 data.frame(name=m[,1], option=FALSE, multiple=!is.na(m[,2]), required=is.na(m[,3]))
#         })
#         argInfo <- do.call(rbind, argInfo)
#         nargs <- nrow(argInfo)
#         if (any(argInfo$multiple[-nargs]))
#             stop("Only the last positional argument can take multiple values")
#     }
#     
#     if (!is.null(attr(spec, "options"))) {
#         opts <- ore_split(",", attr(spec, "options"))
#         longMatches <- ore_search("^(\\w+)(!)?$", opts, simplify=FALSE)
#         validLongOpts <- longMatches[,,1] %in% optInfo$long
#         
#         for (i in seq_along(opts)) {
#             if (validLongOpts[i]) {
#                 index <- which(optInfo$long == longMatches[i,,1])
#                 argInfo <- rbind(argInfo, data.frame(name=optInfo$name[index], option=TRUE, multiple=FALSE, required=!is.na(longMatches[i,,2])))
#             } else {
#                 shortMatches <- ore_search("(\\w)(!)?", opts[i], all=TRUE)
#                 if (!all(shortMatches[,1] %in% optInfo$short))
#                     stop("Pattern uses options not included in the main specification")
#                 indices <- match(shortMatches[,1], optInfo$short)
#                 argInfo <- rbind(argInfo, data.frame(name=optInfo$name[indices], option=TRUE, multiple=FALSE, required=!is.na(shortMatches[,2])))
#             }
#         }
#     }
#     
#     print(argInfo)
#     return(argInfo)
# }
# 
# matchPattern <- function (pattern, parsed) {
#     result <- list()
#     
#     args <- subset(pattern, !option)
#     nargs <- nrow(args)
#     if (nargs > 0) {
#         npargs <- length(parsed$.args)
#         if (sum(args$required) > npargs)
#             return (NULL)   # Too few arguments
#         if (!any(args$multiple) && npargs > nargs)
#             return (NULL)   # Too many arguments
#         
#         for (i in seq_len(nargs)) {
#             if (args$multiple[i] && i <= npargs)
#                 result[[args$name[i]]] <- parsed$.args[i:npargs]
#             else
#                 result[[args$name[i]]] <- parsed$.args[i]
#         }
#     }
#     
#     opts <- subset(pattern, option)
#     nopts <- nrow(opts)
#     if (nopts > 0) {
#         for (i in seq_len(nopts)) {
#             name <- opts$name[i]
#             if (is.null(parsed[[name]]) && opts$required[i])
#                 return (NULL)   # Required option missing
#             else if (!is.null(parsed[[name]]))
#                 result[[name]] <- parsed[[name]]
#         }
#     }
#     
#     return (result)
# }
# 
# wrap <- function (str, width, indent = 0) {
#     if (indent >= width)
#         stop(es("Width (#{width}) must be greater than the indent (#{indent})"))
#     if (length(str) > 0) {
#         str <- ore_subst(es("(\\X{1,#{width-indent}})\\s+"), "\\1\n", str, all=TRUE)
#         cat(paste0(rep(" ",indent), str), "\n\n")
#     }
# }
# 
# parseArgs <- function (name, ..., patterns = list(), header = NULL, footer = NULL) {
#     .opts <- rbind(...)
#     .pats <- lapply(patterns, resolvePattern, .opts)
#     print(.opts)
#     list(parse = function (args = commandArgs(trailingOnly=TRUE)) {
#         args <- expandArgs(args, .opts$short)
#         flags <- as.integer(ore_switch(args, "^--"="2", "^-"="1", "0"))
#         nargs <- length(args)
#         
#         i <- 1
#         result <- structure(mapply("%as%", .opts$default, .opts$mode, SIMPLIFY=FALSE), names=.opts$name)
#         repeat {
#             if (i > nargs) break
#             else if (args[i] == "--") {
#                 i <- i + 1
#                 break
#             } else if (flags[i] == 2L) {
#                 match <- ore_search("^--(\\w+)(=(.*))?$", args[i])
#                 opt <- subset(.opts, long==match[,1])
#                 if (nrow(opt) != 1L)
#                     error(es("Unexpected long-style option: #{args[i]}"))
#                 if (!is.na(match[,3])) {
#                     if (!opt$arg)
#                         stop(es("Long-style option --#{opt$long} does not take an argument"))
#                     result[[opt$long]] <- match[,3] %as% opt$mode
#                 } else if (opt$arg) {
#                     if (i == nargs)
#                         stop(es("Long-style option --#{opt$long} requires an argument"))
#                     else if (flags[i+1] > 0L)
#                         warning(es("Flag-like argument #{args[i+1]} will be taken as a parameter to long-style option --#{opt$long}"))
#                     result[[opt$long]] <- args[i+1] %as% opt$mode
#                     i <- i + 1
#                 } else {
#                     result[[opt$long]] <- TRUE
#                 }
#             } else if (flags[i] == 1L) {
#                 opt <- subset(.opts, short==ore_subst("^-","",args[i]))
#                 if (nrow(opt) != 1L)
#                     error(es("Unexpected short-style option: #{args[i]}"))
#                 name <- ifelse(is.na(opt$long), opt$short, opt$long)
#                 if (opt$arg) {
#                     if (i == nargs)
#                         stop(es("Short-style option --#{opt$short} requires an argument"))
#                     else if (flags[i+1] > 0L)
#                         warning(es("Flag-like argument #{args[i+1]} will be taken as a parameter to short-style option --#{opt$short}"))
#                     result[[name]] <- args[i+1] %as% opt$mode
#                     i <- i + 1
#                 } else {
#                     result[[name]] <- TRUE
#                 }
#             } else break
#             i <- i + 1
#         }
#         
#         if (nargs >= i)
#             result[[".args"]] <- args[i:nargs]
#         else
#             result[[".args"]] <- character(0)
#         
#         patternMatches <- lapply(.pats, matchPattern, result)
#         validPatterns <- !sapply(patternMatches, is.null)
#         print(validPatterns)
#         if (!any(validPatterns))
#             stop("Provided arguments do not match any usage pattern")
#         
#         return (patternMatches[[which(validPatterns)[1]]])
#     }, show = function (width = getOption("width")) {
#         wrap(header, width)
#         
#         wrap(footer, width)
#     })
# }

parser <- arrg("furrow",
            opt("h,help", "Display this usage information and exit"),
            opt("z,nohistory", "Do not write the command line used into a history log file"),
            opt("n,stems", "Do not append a suffix to image filenames, giving the file stem instead"),
            opt("r,relative", "Generate paths relative to the working directory, rather than absolute paths"),
            opt("w,workdir", "Specify the working directory, which will be created if necessary", arg="dir", default="."),
            patterns=list(pat("command", "arg...?", options="znrw"),
                          pat(options="h!")),
            header=c("furrow (program v3.5.0, distribution v3.5.0)", "Channel a command through TractoR's shorthand"),
            footer="Run the specified command, which can be any standard program or script on the PATH, after first expanding TractoR's image-path shorthand, such as @FA for the fractional anisotropy map in the current session directory, or /data/subject1@diffusion/data for the diffusion data series from the session rooted at /data/subject1.")

print(args <- parser$parse())
if (isTRUE(args$help))
    parser$show()

# status=1
# tmpdir=${TMPDIR:-/tmp}
# trap 'exit $status' 0 1 2 15
# 
# full_command="$0 $*"
# write_history=1
# suffixes=1
# relative=0
# working_dir=${TRACTOR_WORKING_DIR:-.}
# 
# usage()
# {
#     echo "furrow (program v3.4.1, distribution v$distribution_version)"
#     echo "Channel a command through TractoR's shorthand"
#     echo
#     echo "Usage: furrow [-zn] [-w working_dir] command [arg1 [arg2 ...]]"
#     echo "       furrow -h"
#     echo
#     echo "  -h          Display this usage information and exit"
#     echo "  -z          Do not write the command line used into a history log file"
#     echo "  -n          Do not append a suffix to image filenames, giving the file"
#     echo "              stem instead"
#     echo "  -r          Generate paths relative to the working directory, rather"
#     echo "              than absolute paths"
#     echo "  -w dir      Specify the working directory, which will be created if"
#     echo "              necessary. Default is '.', the current directory"
#     echo
#     echo "Run the specified command, which can be any standard program or script on"
#     echo "the PATH, after first expanding TractoR's image-path shorthand, such as"
#     echo "@FA for the fractional anisotropy map in the current session directory,"
#     echo "or /data/subject1@diffusion/data for the diffusion data series from the"
#     echo "session rooted at /data/subject1."
#     echo
# }
# 
# [ -z "${TRACTOR_HOME}" ] && {
#     echo "Note: The TRACTOR_HOME environment variable is not set; it will be guessed"
#     export TRACTOR_HOME=`echo $0 | sed 's/\/bin\/tractor$//'`
# }
# 
# [ -f "${TRACTOR_HOME}/VERSION" ] && distribution_version=`cat "${TRACTOR_HOME}/VERSION"`
# 
# while getopts "hznrw:" opt; do
#     case "$opt" in
#         h) usage; status=0; exit ;;
#         z) write_history=0 ;;
#         n) suffixes=0 ;;
#         r) relative=1 ;;
#         w) working_dir=`echo $OPTARG | sed 's/\/$//'` ;;
#         ?) usage 1>&2; exit ;;
#     esac
# done
# 
# shift "$(($OPTIND-1))"
# 
# [ $# -eq 0 ] && {
#     echo "Error: No command given. Type \"furrow -h\" for help" 1>&2
#     exit
# }
# 
# [ ! -e "$working_dir" ] && mkdir -p "$working_dir"
# 
# command="$1"
# shift
# 
# [ -z "$R" ] && R=R
# 
# [ -d "${TRACTOR_HOME}/lib/R" ] && export R_LIBS="${TRACTOR_HOME}/lib/R"
# 
# args=`echo "library(utils); library(tractor.utils); library(tractor.session); expandArguments('$*','$working_dir',$suffixes,$relative)" | "$R" --slave --vanilla`
# 
# status=$?
# [ $status -ne 0 ] && exit
# 
# cd "$working_dir" && eval "$command $args"
# 
# status=$?
# 
# # We are now in the working directory, so don't preface the log filename with it
# [ $write_history -eq 1 ] && echo "[`date`] $full_command [${status}S]" >> tractor-history.log
